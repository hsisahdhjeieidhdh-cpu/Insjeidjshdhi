-- First, show the loading screen
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

-- Create loader function
local function showLoader()
    local loaderComplete = false
    
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "injection_cc_loader"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.IgnoreGuiInset = true

    -- Create blur effect
    local blurEffect = Instance.new("DepthOfFieldEffect")
    blurEffect.FarIntensity = 0
    blurEffect.NearIntensity = 20
    blurEffect.InFocusRadius = 0
    blurEffect.Name = "InjectionBlur"
    blurEffect.Enabled = true
    blurEffect.Parent = Lighting

    -- Main loader container
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainLoader"
    mainFrame.Size = UDim2.new(0.4, 0, 0.5, 0)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    mainFrame.BackgroundTransparency = 0.2
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui

    -- Add rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = mainFrame

    -- Add subtle border
    local border = Instance.new("UIStroke")
    border.Color = Color3.fromRGB(100, 150, 255)
    border.Thickness = 2
    border.Transparency = 0.7
    border.Parent = mainFrame

    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0.2, 0)
    title.Position = UDim2.new(0, 0, 0.05, 0)
    title.BackgroundTransparency = 1
    title.Text = "injection.cc"
    title.TextColor3 = Color3.fromRGB(180, 220, 255)
    title.TextScaled = true
    title.Font = Enum.Font.GothamBold
    title.TextStrokeTransparency = 0.8
    title.TextStrokeColor3 = Color3.fromRGB(80, 120, 200)
    title.Parent = mainFrame

    -- Subtitle
    local subtitle = Instance.new("TextLabel")
    subtitle.Name = "Subtitle"
    subtitle.Size = UDim2.new(1, 0, 0.1, 0)
    subtitle.Position = UDim2.new(0, 0, 0.25, 0)
    subtitle.BackgroundTransparency = 1
    subtitle.Text = "Loading injection..."
    subtitle.TextColor3 = Color3.fromRGB(200, 200, 220)
    subtitle.TextScaled = true
    subtitle.Font = Enum.Font.Gotham
    subtitle.TextSize = 18
    subtitle.Parent = mainFrame

    -- Loading Bar Container
    local barContainer = Instance.new("Frame")
    barContainer.Name = "BarContainer"
    barContainer.Size = UDim2.new(0.8, 0, 0.06, 0)
    barContainer.AnchorPoint = Vector2.new(0.5, 0)
    barContainer.Position = UDim2.new(0.5, 0, 0.45, 0)
    barContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
    barContainer.BackgroundTransparency = 0.3
    barContainer.BorderSizePixel = 0
    barContainer.Parent = mainFrame

    local barContainerCorner = Instance.new("UICorner")
    barContainerCorner.CornerRadius = UDim.new(0, 6)
    barContainerCorner.Parent = barContainer

    -- Loading Bar
    local loadingBar = Instance.new("Frame")
    loadingBar.Name = "LoadingBar"
    loadingBar.Size = UDim2.new(0, 0, 1, 0)
    loadingBar.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    loadingBar.BorderSizePixel = 0
    loadingBar.Parent = barContainer

    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 6)
    barCorner.Parent = loadingBar

    -- Progress Text
    local progressText = Instance.new("TextLabel")
    progressText.Name = "ProgressText"
    progressText.Size = UDim2.new(1, 0, 0.1, 0)
    progressText.Position = UDim2.new(0, 0, 0.55, 0)
    progressText.BackgroundTransparency = 1
    progressText.Text = "0%"
    progressText.TextColor3 = Color3.fromRGB(220, 220, 240)
    progressText.TextScaled = true
    progressText.Font = Enum.Font.GothamMedium
    progressText.TextSize = 16
    progressText.Parent = mainFrame

    -- Status Container
    local statusContainer = Instance.new("Frame")
    statusContainer.Name = "StatusContainer"
    statusContainer.Size = UDim2.new(0.9, 0, 0.25, 0)
    statusContainer.AnchorPoint = Vector2.new(0.5, 0)
    statusContainer.Position = UDim2.new(0.5, 0, 0.68, 0)
    statusContainer.BackgroundTransparency = 1
    statusContainer.Parent = mainFrame

    -- Status messages
    local statusMessages = {
        "Loading core modules",
        "Initializing graphics",
        "Connecting to services",
        "Verifying security",
        "Optimizing performance",
        "Finalizing setup"
    }

    local statusLabels = {}
    for i = 1, 4 do
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "Status" .. i
        statusLabel.Size = UDim2.new(1, 0, 0.2, 0)
        statusLabel.Position = UDim2.new(0, 0, (i-1) * 0.25, 0)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Text = ""
        statusLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
        statusLabel.TextXAlignment = Enum.TextXAlignment.Left
        statusLabel.Font = Enum.Font.Gotham
        statusLabel.TextSize = 14
        statusLabel.Parent = statusContainer
        table.insert(statusLabels, statusLabel)
    end

    -- Create snow particles
    local function createSnow()
        local snowContainer = Instance.new("Frame")
        snowContainer.Name = "SnowContainer"
        snowContainer.Size = UDim2.new(1, 0, 1, 0)
        snowContainer.BackgroundTransparency = 1
        snowContainer.Parent = screenGui
        
        local snowflakes = {}
        
        for i = 1, 20 do
            local snowflake = Instance.new("Frame")
            snowflake.Name = "Snowflake" .. i
            snowflake.Size = UDim2.new(0, math.random(4, 8), 0, math.random(4, 8))
            snowflake.Position = UDim2.new(0, math.random(-100, 900), 0, math.random(-100, 700))
            snowflake.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            snowflake.BackgroundTransparency = math.random(3, 7) / 10
            snowflake.BorderSizePixel = 0
            
            local snowCorner = Instance.new("UICorner")
            snowCorner.CornerRadius = UDim.new(1, 0)
            snowCorner.Parent = snowflake
            
            snowflake.Parent = snowContainer
            table.insert(snowflakes, snowflake)
        end
        
        return snowflakes
    end

    -- Animate snow
    local function animateSnow(snowflakes)
        for _, flake in pairs(snowflakes) do
            spawn(function()
                local startY = flake.Position.Y.Offset
                local speed = math.random(20, 40) / 10
                local sway = math.random(-2, 2)
                
                while flake and flake.Parent do
                    local currentY = flake.Position.Y.Offset
                    local currentX = flake.Position.X.Offset
                    
                    local newY = currentY + speed
                    local newX = currentX + math.sin(tick() * 2) * sway
                    
                    if newY > 700 then
                        newY = -50
                        newX = math.random(-100, 900)
                    end
                    if newX < -100 then newX = 900 end
                    if newX > 900 then newX = -100 end
                    
                    flake.Position = UDim2.new(0, newX, 0, newY)
                    
                    RunService.RenderStepped:Wait()
                end
            end)
        end
    end

    -- Simple pulse animation for loading bar
    local pulseActive = true
    local function pulseBar()
        while pulseActive and loadingBar and loadingBar.Parent do
            local tween1 = TweenService:Create(
                loadingBar,
                TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {BackgroundColor3 = Color3.fromRGB(120, 170, 255)}
            )
            local tween2 = TweenService:Create(
                loadingBar,
                TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
                {BackgroundColor3 = Color3.fromRGB(100, 150, 255)}
            )
            
            tween1:Play()
            tween1.Completed:Wait()
            tween2:Play()
            tween2.Completed:Wait()
        end
    end

    -- Get player GUI
    local player = Players.LocalPlayer
    if not player then
        Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
        player = Players.LocalPlayer
    end
    
    local playerGui = player:WaitForChild("PlayerGui")
    screenGui.Parent = playerGui

    -- Start loading animation
    local snowflakes = createSnow()
    animateSnow(snowflakes)
    
    spawn(pulseBar)
    
    -- Simulate loading
    local totalSteps = 100
    local currentStep = 0
    local statusIndex = 1
    
    while currentStep < totalSteps do
        currentStep = currentStep + math.random(1, 4)
        if currentStep > totalSteps then
            currentStep = totalSteps
        end
        
        local progress = currentStep / totalSteps
        loadingBar.Size = UDim2.new(progress, 0, 1, 0)
        progressText.Text = math.floor(progress * 100) .. "%"
        
        if progress > 0.2 and statusIndex == 1 then
            statusLabels[1].Text = "âœ“ " .. statusMessages[1]
            statusLabels[1].TextColor3 = Color3.fromRGB(100, 255, 100)
            statusIndex = 2
        elseif progress > 0.4 and statusIndex == 2 then
            statusLabels[2].Text = "âœ“ " .. statusMessages[2]
            statusLabels[2].TextColor3 = Color3.fromRGB(100, 255, 100)
            statusIndex = 3
        elseif progress > 0.6 and statusIndex == 3 then
            statusLabels[3].Text = "âœ“ " .. statusMessages[3]
            statusLabels[3].TextColor3 = Color3.fromRGB(100, 255, 100)
            statusIndex = 4
        elseif progress > 0.8 and statusIndex == 4 then
            statusLabels[4].Text = "âœ“ " .. statusMessages[4]
            statusLabels[4].TextColor3 = Color3.fromRGB(100, 255, 100)
            statusIndex = 5
        end
        
        if progress < 0.3 then
            subtitle.Text = "Loading libraries..."
        elseif progress < 0.6 then
            subtitle.Text = "Setting up UI..."
        elseif progress < 0.9 then
            subtitle.Text = "Finalizing..."
        else
            subtitle.Text = "Almost ready..."
        end
        
        wait(math.random(0.05, 0.1))
    end
    
    -- Final updates
    statusLabels[1].Text = "âœ“ " .. statusMessages[5]
    statusLabels[1].TextColor3 = Color3.fromRGB(100, 255, 100)
    wait(0.3)
    
    statusLabels[2].Text = "âœ“ " .. statusMessages[6]
    statusLabels[2].TextColor3 = Color3.fromRGB(100, 255, 100)
    
    subtitle.Text = "INJECTION LOADED"
    progressText.Text = "100% - READY"
    
    -- Flash bar green
    for i = 1, 3 do
        loadingBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
        wait(0.1)
        loadingBar.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
        wait(0.1)
    end
    
    loadingBar.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
    
    wait(0.5)
    
    -- Stop pulse
    pulseActive = false
    
    -- Fade out loader
    local fadeTween = TweenService:Create(
        mainFrame,
        TweenInfo.new(0.5, Enum.EasingStyle.Quad),
        {BackgroundTransparency = 1}
    )
    fadeTween:Play()
    
    for _, child in pairs(mainFrame:GetDescendants()) do
        if child:IsA("TextLabel") then
            TweenService:Create(
                child,
                TweenInfo.new(0.5, Enum.EasingStyle.Quad),
                {TextTransparency = 1, TextStrokeTransparency = 1}
            ):Play()
        end
    end
    
    for _, snowflake in pairs(snowflakes) do
        if snowflake then
            TweenService:Create(
                snowflake,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                {BackgroundTransparency = 1}
            ):Play()
        end
    end
    
    wait(0.6)
    
    -- Disable blur
    blurEffect.Enabled = false
    blurEffect:Destroy()
    
    -- Destroy GUI
    screenGui:Destroy()
    
    loaderComplete = true
    return true
end

-- Wait a bit before starting the loader
wait(0.5)

-- Show the loader
local loaderSuccess = pcall(showLoader)

-- After loader finishes, load the main script
if loaderSuccess then
    print("Loader completed successfully, starting main injection...")
else
    print("Loader had issues, but continuing with main script...")
end

-- Wait a bit before loading main UI
wait(0.2)

-- NOW LOAD THE MAIN INJECTION AIMBOT SCRIPT
-- Injection Aimbot with LinoriaLib UI

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

-- Set up services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Settings
local Injection = {
    Tech = {
        Enabled = true,
        LockType = "Namecall",
        SelectedPart = "HumanoidRootPart",
        AirPart = "RightFoot",
        AntiAimViewer = false,
        SilentMode = false,
        AutoPrediction = false,
        HorizontalPrediction = 0.181,
        VerticalPrediction = 0.181,
        HorizontalPrediction2 = 0.181,
        VerticalPrediction2 = 0.181,
        jumpoffset = -0.03,
        jumpoffset2 = -0.3,
        jumpoffset3 = 0.270,
        UseVertical = false,
        ResolverEnabled = false,
        RESOLVER = "MoveDirection",
        KOCheck = true,
        WallCheck = false,
        FriendCheck = false,
        SeatedCheck = false,
        TeamCheck = false,
        UnlockOnKO = false,
        LookAt = false,
        ViewAt = false,
        AutoAir = false,
        AutoAirDelay = 0.22,
        AutoShoot = false,
        MacroSpeed = 0.2,
        cframespeedtoggle = false,
        speedvalue = 3
    }
}

local TargetAimbot = {
    Enabled = true,
    Highlight = true,
    HighlightColor1 = Color3.fromRGB(255, 0, 0),
    HighlightColor2 = Color3.fromRGB(255, 100, 100)
}

-- Variables
local TargetPlr = nil
local TargBindEnabled = false
local targetHealth = nil
local lastTick = tick()
local lastPos = nil
local targetSigmaPOBALLs = nil
local Shot2ing = false
local TargHighlight = Instance.new("Highlight")
TargHighlight.Parent = game:GetService("CoreGui")
TargHighlight.FillColor = TargetAimbot.HighlightColor1
TargHighlight.OutlineColor = TargetAimbot.HighlightColor2
TargHighlight.FillTransparency = 0.5
TargHighlight.OutlineTransparency = 0
TargHighlight.Enabled = false

-- Walkspeed and Jump Power variables
local walkspeedEnabled = false
local jumpspeedEnabled = false
local originalWalkspeed = 16
local originalJumppower = 50

-- Prediction table for auto prediction
local predictionTable = {
    {20, 0.08960952},
    {30, 0.11252476},
    {50, 0.13544},
    {65, 0.1264236},
    {70, 0.12533},
    {80, 0.139340},
    {100, 0.141987},
    {110, 0.144634},
    {120, 0.147281},
    {130, 0.149928},
    {140, 0.152575},
    {150, 0.155222},
    {160, 0.157869},
    {170, 0.160516},
    {180, 0.163163},
    {190, 0.165810},
    {200, 0.168457},
    {210, 0.171104},
    {220, 0.173751},
    {230, 0.176398},
    {240, 0.179045},
    {250, 0.181692},
    {260, 0.184339},
    {270, 0.186986},
    {280, 0.189633},
    {290, 0.192280},
    {300, 0.194927}
}

-- Create the Camlock Button GUI
local CamlockButtonGUI = Instance.new("ScreenGui")
CamlockButtonGUI.Name = "CamlockButtonGUI"
CamlockButtonGUI.Parent = game.CoreGui
CamlockButtonGUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
CamlockButtonGUI.ResetOnSpawn = false

local CamlockButton = Instance.new("ImageButton")
CamlockButton.Name = "CamlockButton"
CamlockButton.Parent = CamlockButtonGUI
CamlockButton.Active = true
CamlockButton.Draggable = true
CamlockButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CamlockButton.BackgroundTransparency = 0.3
CamlockButton.Size = UDim2.new(0, 80, 0, 80)
CamlockButton.Image = "rbxassetid://85536473526362"
CamlockButton.Position = UDim2.new(1, -90, 0.5, -40)

local CamlockCorner = Instance.new("UICorner")
CamlockCorner.CornerRadius = UDim.new(0.2, 0)
CamlockCorner.Parent = CamlockButton

local CamlockStroke = Instance.new("UIStroke")
CamlockStroke.Parent = CamlockButton
CamlockStroke.Color = Color3.fromRGB(255, 0, 0)
CamlockStroke.Thickness = 2

-- Create LinoriaLib Window
local Window = Library:CreateWindow({
    Title = "Injection Aimbot",
    Footer = "version: 1.0",
    Icon = 95816097006870,
    NotifySide = "Right",
    ShowCustomCursor = true,
})

local Tabs = {
    Main = Window:AddTab("Aimbot", "target"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "settings"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- AIMBOT FUNCTIONS

local function isPlayerKO(player)
    if not player.Character then return false end
    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    if bodyEffects then
        local KO = bodyEffects:FindFirstChild("K.O")
        if KO and KO:IsA("BoolValue") and KO.Value then return true end
    end
    return false
end

local function BehindWall(player)
    if not player or player == LocalPlayer or not player.Character then return true end
    local targetPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return true end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).unit * (targetPart.Position - origin).magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, player.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = Workspace:Raycast(origin, direction, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

local function isPlayerSeated(player)
    if not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.SeatPart ~= nil
end

local function isPlayerOnSameTeam(player)
    if not player.Team or not LocalPlayer.Team then return false end
    return player.Team == LocalPlayer.Team
end

local function GetPlayerLookingAt()
    local closestPlayer = nil
    local closestAngle = math.rad(10)
    
    local cameraDirection = Camera.CFrame.LookVector
    local cameraPosition = Camera.CFrame.Position
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if Injection.Tech.FriendCheck and LocalPlayer:IsFriendsWith(player.UserId) then
                continue
            end
            
            if Injection.Tech.TeamCheck and isPlayerOnSameTeam(player) then
                continue
            end
            
            if Injection.Tech.KOCheck and isPlayerKO(player) then
                continue
            end
            
            if Injection.Tech.SeatedCheck and isPlayerSeated(player) then
                continue
            end
            
            if Injection.Tech.WallCheck and BehindWall(player) then
                continue
            end
            
            local targetPosition = player.Character.HumanoidRootPart.Position
            local directionToTarget = (targetPosition - cameraPosition).Unit
            
            local dotProduct = cameraDirection:Dot(directionToTarget)
            local angle = math.acos(dotProduct)
            
            if angle < closestAngle then
                closestAngle = angle
                closestPlayer = player
            end
        end
    end
    
    return closestPlayer
end

local function GetClosestToMouse()
    local TargetPlr, Closest = nil, math.huge
    
    for _, v in pairs(Players:GetPlayers()) do
        if (v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart")) then
            local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
            local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
            
            if (Distance < Closest and OnScreen) then
                Closest = Distance
                TargetPlr = v
            end
        end
    end
    return TargetPlr
end

local function TargetFuturePosition()
    if TargetPlr and TargetPlr.Character then
        local selectedPart = Injection.Tech.SelectedPart
        local targetPart = TargetPlr.Character[selectedPart]
        
        if targetPart then
            local currentTick = tick()
            local currentPos = targetPart.CFrame
            
            local velocity = Vector3.new(0, 0, 0)
            
            if Injection.Tech.ResolverEnabled then
                if Injection.Tech.RESOLVER == "Recalculate" then
                    if lastPos then
                        local delta = currentTick - lastTick
                        if delta > 0 then
                            local positionDifference = currentPos - lastPos
                            velocity = positionDifference / delta
                        end
                    end
                    lastPos = currentPos
                    lastTick = currentTick
                elseif Injection.Tech.RESOLVER == "MoveDirection" then
                    velocity = TargetPlr.Character.Humanoid.MoveDirection * TargetPlr.Character.Humanoid.WalkSpeed
                elseif Injection.Tech.RESOLVER == "LookVector" then
                    velocity = targetPart.CFrame.LookVector * Injection.Tech.HorizontalPrediction * 1.5
                end
            else
                velocity = targetPart.AssemblyLinearVelocity
            end
            
            local horizontalPrediction = Injection.Tech.HorizontalPrediction
            local verticalPrediction = Injection.Tech.VerticalPrediction
            local jumpOffset = Injection.Tech.jumpoffset or 0
            
            if Injection.Tech.UseVertical then
                return Vector3.new(
                    currentPos.X + (velocity.X / horizontalPrediction),
                    currentPos.Y + (velocity.Y / verticalPrediction),
                    currentPos.Z + (velocity.Z / horizontalPrediction)
                ) + Vector3.new(0, jumpOffset, 0)
            else
                return Vector3.new(
                    currentPos.X + (velocity.X * horizontalPrediction),
                    currentPos.Y + (velocity.Y * verticalPrediction),
                    currentPos.Z + (velocity.Z * horizontalPrediction)
                ) + Vector3.new(0, jumpOffset, 0)
            end
        end
    end
    return nil
end

local function checkAutoAir()
    if TargetPlr and TargetPlr.Character and Injection.Tech.AutoAir then
        local humanoid = TargetPlr.Character:FindFirstChildOfClass("Humanoid")
        local humanoidRootPart = TargetPlr.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and humanoidRootPart then
            local SigmaAir = humanoid:GetState() == Enum.HumanoidStateType.Freefall
            
            if SigmaAir then
                if not targetSigmaPOBALLs then
                    targetSigmaPOBALLs = tick()
                else
                    local airDuration = tick() - targetSigmaPOBALLs
                    if airDuration >= Injection.Tech.AutoAirDelay then
                        if not Shot2ing then
                            Shot2ing = true
                            
                            local character = LocalPlayer.Character
                            if character then
                                local tool = character:FindFirstChildOfClass("Tool")
                                if tool then
                                    while TargetPlr and TargetPlr.Character and SigmaAir do
                                        tool:Activate()
                                        task.wait(0.00001)
                                        
                                        if TargetPlr.Character:FindFirstChildOfClass("Humanoid") then
                                            SigmaAir = TargetPlr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall
                                        else
                                            SigmaAir = false
                                        end
                                        
                                        if not SigmaAir then
                                            Shot2ing = false
                                            targetSigmaPOBALLs = nil
                                            break
                                        end
                                    end
                                    Shot2ing = false
                                end
                            end
                        end
                    end
                end
            else
                targetSigmaPOBALLs = nil
                Shot2ing = false
            end
        end
    end
end

local function updateAutoPrediction()
    if not Injection.Tech.AutoPrediction then return end
    
    local function findClosestPrediction(ping)
        local closestValue, closestDiff = nil, math.huge
        for _, entry in ipairs(predictionTable) do
            local diff = math.abs(ping - entry[1])
            if diff < closestDiff then
                closestDiff = diff
                closestValue = entry[2]
            end
        end
        return closestValue
    end
    
    local ping = 100
    local predValue = findClosestPrediction(ping)
    
    if predValue then
        Injection.Tech.HorizontalPrediction = predValue
        Injection.Tech.VerticalPrediction = predValue * 0.910
        Injection.Tech.HorizontalPrediction2 = predValue
        Injection.Tech.VerticalPrediction2 = predValue * 0.910
        
        if Options.PredictionTextBox then
            Options.PredictionTextBox:SetText(tostring(predValue))
        end
    end
end

local function toggleCamlock()
    if TargetAimbot.Enabled then
        if TargBindEnabled and TargetPlr then
            TargBindEnabled = false
            targetHealth = nil
            targetSigmaPOBALLs = nil
            Shot2ing = false
            TargetPlr = nil
            print("ðŸŽ¯ [INJECTION] Untargeted")
            CamlockButton.Image = "rbxassetid://85536473526362"
            CamlockStroke.Color = Color3.fromRGB(255, 0, 0)
            
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                Camera.CameraSubject = LocalPlayer.Character.Humanoid
                LocalPlayer.Character.Humanoid.AutoRotate = true
            end
        else
            local target = GetPlayerLookingAt()
            if not target then
                target = GetClosestToMouse()
            end
            
            if target then
                TargBindEnabled = true
                TargetPlr = target
                
                if TargetPlr.Character and TargetPlr.Character:FindFirstChild("Humanoid") then
                    targetHealth = TargetPlr.Character.Humanoid.Health
                end
                
                print("ðŸŽ¯ [INJECTION] Target Locked: " .. TargetPlr.Name)
                CamlockButton.Image = "rbxassetid://89420402731484"
                CamlockStroke.Color = Color3.fromRGB(0, 255, 0)
            else
                print("ðŸŽ¯ [INJECTION] No target found")
            end
        end
    end
end

CamlockButton.MouseButton1Click:Connect(toggleCamlock)

local Argumen = {"UpdateMousePos", "GetMousePos", "MousePos", "MOUSE", "MousePosUpdate", "UpdateMousePosI2", "UpdateMousePosI", "UpdateAim"}
local Argument

local function setupNamecallHook()
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(...)
        local args = {...}
        local method = getnamecallmethod()
        
        if Injection.Tech.Enabled and Injection.Tech.LockType == "Namecall" then
            if TargetPlr and TargetPlr.Character and method == "FireServer" then
                for _, methodName in ipairs(Argumen) do
                    if args[2] == methodName then
                        Argument = methodName
                        if not Injection.Tech.AntiAimViewer then
                            local aimPosition = TargetFuturePosition()
                            if aimPosition then
                                args[3] = aimPosition
                                return old(unpack(args))
                            end
                        end
                    end
                end
            end
        end
        
        return old(...)
    end)
    
    setreadonly(mt, true)
end

local function setupIndexHook()
    local Hooks = {}
    
    Hooks[1] = hookmetamethod(Mouse, "__index", newcclosure(function(self, index)
        if index == "Hit" and Injection.Tech.LockType == "Index" and Injection.Tech.Enabled and 
           TargetPlr and TargetPlr.Character and Injection.Tech.SelectedPart then
            local targetPos = TargetFuturePosition()
            if targetPos then
                return CFrame.new(targetPos)
            end
        end
        return Hooks[1](self, index)
    end))
end

setupNamecallHook()
setupIndexHook()

-- LINORIA LIB UI SETUP

local AimGroup = Tabs.Main:AddLeftGroupbox("Aimbot Settings")

AimGroup:AddToggle("EnableAimbot", {
    Text = "Enable Aimbot",
    Default = true,
    Tooltip = "Toggle the aimbot on/off",
    
    Callback = function(Value)
        Injection.Tech.Enabled = Value
    end,
})

AimGroup:AddDropdown("LockType", {
    Values = {"Namecall", "Index"},
    Default = "Namecall",
    Text = "Lock Type",
    Tooltip = "Method used for locking onto targets",
    
    Callback = function(Value)
        Injection.Tech.LockType = Value
    end,
})

AimGroup:AddDivider()

-- CHANGED: Prediction slider to text box
AimGroup:AddInput("PredictionTextBox", {
    Text = "Prediction",
    Default = "0.181",
    Numeric = true,
    Finished = false,
    Placeholder = "Enter prediction value",
    Tooltip = "Set prediction value (0.01 to 0.5)",
    
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            num = math.clamp(num, 0.01, 0.5)
            Injection.Tech.HorizontalPrediction = num
            Injection.Tech.VerticalPrediction = num
            Injection.Tech.HorizontalPrediction2 = num
            Injection.Tech.VerticalPrediction2 = num
        else
            Library:Notify({
                Title = "Invalid Input",
                Description = "Please enter a valid number between 0.01 and 0.5",
                Time = 3,
            })
        end
    end,
})

AimGroup:AddToggle("AutoPrediction", {
    Text = "Auto Prediction",
    Default = false,
    Tooltip = "Automatically adjust prediction based on ping",
    
    Callback = function(Value)
        Injection.Tech.AutoPrediction = Value
    end,
})

AimGroup:AddDivider()

AimGroup:AddToggle("AutoAir", {
    Text = "Auto Air",
    Default = false,
    Tooltip = "Auto shoot when target is in air",
    
    Callback = function(Value)
        Injection.Tech.AutoAir = Value
    end,
})

AimGroup:AddSlider("JumpOffset", {
    Text = "Jump Offset",
    Default = -0.03,
    Min = -1,
    Max = 1,
    Rounding = 2,
    Suffix = "",
    Tooltip = "Adjust jump offset for prediction",
    
    Callback = function(Value)
        Injection.Tech.jumpoffset = Value
    end,
})

AimGroup:AddToggle("Resolver", {
    Text = "Resolver",
    Default = false,
    Tooltip = "Enable velocity resolver",
    
    Callback = function(Value)
        Injection.Tech.ResolverEnabled = Value
    end,
})

AimGroup:AddToggle("WallCheck", {
    Text = "Wall Check",
    Default = false,
    Tooltip = "Don't shoot through walls",
    
    Callback = function(Value)
        Injection.Tech.WallCheck = Value
    end,
})

AimGroup:AddDivider()

AimGroup:AddButton({
    Text = "Toggle Camlock",
    Func = toggleCamlock,
    Tooltip = "Manually toggle camlock",
})

local ChecksGroup = Tabs.Main:AddRightGroupbox("Checks")

ChecksGroup:AddToggle("KOCheck", {
    Text = "KO Check",
    Default = true,
    Tooltip = "Don't target KO'd players",
    
    Callback = function(Value)
        Injection.Tech.KOCheck = Value
    end,
})

ChecksGroup:AddToggle("FriendCheck", {
    Text = "Friend Check",
    Default = false,
    Tooltip = "Don't target friends",
    
    Callback = function(Value)
        Injection.Tech.FriendCheck = Value
    end,
})

ChecksGroup:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = false,
    Tooltip = "Don't target teammates",
    
    Callback = function(Value)
        Injection.Tech.TeamCheck = Value
    end,
})

ChecksGroup:AddToggle("SeatedCheck", {
    Text = "Seated Check",
    Default = false,
    Tooltip = "Don't target seated players",
    
    Callback = function(Value)
        Injection.Tech.SeatedCheck = Value
    end,
})

ChecksGroup:AddToggle("UnlockOnKO", {
    Text = "Unlock on KO",
    Default = false,
    Tooltip = "Auto unlock when target gets KO'd",
    
    Callback = function(Value)
        Injection.Tech.UnlockOnKO = Value
    end,
})

local VisualsGroup = Tabs.Visuals:AddLeftGroupbox("Target Visuals")

VisualsGroup:AddToggle("TargetHighlight", {
    Text = "Highlight Target",
    Default = true,
    Tooltip = "Highlight the locked target",
    
    Callback = function(Value)
        TargetAimbot.Highlight = Value
    end,
}):AddColorPicker("HighlightColor1", {
    Default = Color3.fromRGB(255, 0, 0),
    Title = "Highlight Color",
    
    Callback = function(Value)
        TargetAimbot.HighlightColor1 = Value
        TargHighlight.FillColor = Value
    end,
})

VisualsGroup:AddToggle("LookAt", {
    Text = "Look At Target",
    Default = false,
    Tooltip = "Make character look at target",
    
    Callback = function(Value)
        Injection.Tech.LookAt = Value
    end,
})

VisualsGroup:AddToggle("ViewAt", {
    Text = "View Target",
    Default = false,
    Tooltip = "Make camera follow target",
    
    Callback = function(Value)
        Injection.Tech.ViewAt = Value
    end,
})

local MiscGroup = Tabs.Misc:AddLeftGroupbox("Movement")

MiscGroup:AddToggle("WalkSpeed", {
    Text = "WalkSpeed",
    Default = false,
    Tooltip = "Enable custom walkspeed",
    
    Callback = function(Value)
        walkspeedEnabled = Value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            if Value then
                originalWalkspeed = LocalPlayer.Character.Humanoid.WalkSpeed
                LocalPlayer.Character.Humanoid.WalkSpeed = 50
            else
                LocalPlayer.Character.Humanoid.WalkSpeed = originalWalkspeed
            end
        end
    end,
})

MiscGroup:AddSlider("WalkSpeedValue", {
    Text = "WalkSpeed Value",
    Default = 50,
    Min = 16,
    Max = 200,
    Rounding = 1,
    Suffix = "",
    Tooltip = "Set walkspeed value",
    
    Callback = function(Value)
        if walkspeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.WalkSpeed = Value
        end
    end,
})

MiscGroup:AddToggle("JumpPower", {
    Text = "Jump Power",
    Default = false,
    Tooltip = "Enable custom jump power",
    
    Callback = function(Value)
        jumpspeedEnabled = Value
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            if Value then
                originalJumppower = LocalPlayer.Character.Humanoid.JumpPower
                LocalPlayer.Character.Humanoid.JumpPower = 100
            else
                LocalPlayer.Character.Humanoid.JumpPower = originalJumppower
            end
        end
    end,
})

MiscGroup:AddSlider("JumpPowerValue", {
    Text = "Jump Power Value",
    Default = 100,
    Min = 50,
    Max = 200,
    Rounding = 1,
    Suffix = "",
    Tooltip = "Set jump power value",
    
    Callback = function(Value)
        if jumpspeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid.JumpPower = Value
        end
    end,
})

MiscGroup:AddDivider()

MiscGroup:AddToggle("CFrameSpeed", {
    Text = "CFrame Speed",
    Default = false,
    Tooltip = "Enable CFrame speed boost",
    
    Callback = function(Value)
        Injection.Tech.cframespeedtoggle = Value
    end,
})

MiscGroup:AddSlider("SpeedValue", {
    Text = "Speed Value",
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0.1,
    Suffix = "",
    Tooltip = "Set CFrame speed multiplier",
    
    Callback = function(Value)
        Injection.Tech.speedvalue = Value
    end,
})

local MiscGroup2 = Tabs.Misc:AddRightGroupbox("Aimbot Misc")

MiscGroup2:AddToggle("AutoShoot", {
    Text = "Auto Shoot",
    Default = false,
    Tooltip = "Auto shoot when target is locked",
    
    Callback = function(Value)
        Injection.Tech.AutoShoot = Value
    end,
})

MiscGroup2:AddToggle("SilentMode", {
    Text = "Silent Aim",
    Default = false,
    Tooltip = "Auto target without locking",
    
    Callback = function(Value)
        Injection.Tech.SilentMode = Value
    end,
})

MiscGroup2:AddButton({
    Text = "Hide Camlock Button",
    Func = function()
        CamlockButtonGUI.Enabled = not CamlockButtonGUI.Enabled
        Library:Notify({
            Title = "Camlock Button",
            Description = CamlockButtonGUI.Enabled and "Shown" or "Hidden",
            Time = 2,
        })
    end,
    Tooltip = "Toggle visibility of the camlock button",
})

MiscGroup2:AddDivider()

MiscGroup2:AddLabel("Camlock Keybind"):AddKeyPicker("CamlockKeybind", {
    Default = "Q",
    Mode = "Toggle",
    Text = "Camlock Keybind",
    
    Callback = function(Value)
        if Value then
            toggleCamlock()
        end
    end,
})

-- GAME FUNCTIONS

-- Update character properties on character added
LocalPlayer.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid")
    
    if walkspeedEnabled then
        character.Humanoid.WalkSpeed = Options.WalkSpeedValue.Value
    end
    
    if jumpspeedEnabled then
        character.Humanoid.JumpPower = Options.JumpPowerValue.Value
    end
end)

RunService.RenderStepped:Connect(function()
    if TargetAimbot.Enabled and TargBindEnabled and TargetAimbot.Highlight and 
       TargetPlr and TargetPlr.Character then
        TargHighlight.FillColor = TargetAimbot.HighlightColor1
        TargHighlight.OutlineColor = TargetAimbot.HighlightColor2
        TargHighlight.Adornee = TargetPlr.Character
        TargHighlight.Enabled = true
    else
        TargHighlight.Adornee = nil
        TargHighlight.Enabled = false
    end
end)

RunService.Stepped:Connect(function()
    if Injection.Tech.LookAt and TargBindEnabled and TargetPlr and LocalPlayer.Character then
        local character = LocalPlayer.Character
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        
        if humanoid and humanoidRootPart and TargetPlr.Character then
            local targetRoot = TargetPlr.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                local lookPosition = Vector3.new(targetRoot.Position.X, humanoidRootPart.Position.Y, targetRoot.Position.Z)
                humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, lookPosition)
                humanoid.AutoRotate = false
            end
        end
    elseif LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.AutoRotate = true
    end
end)

-- CFrame speed function
RunService.Heartbeat:Connect(function()
    if Injection.Tech.cframespeedtoggle and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoidRootPart = LocalPlayer.Character.HumanoidRootPart
        local moveDirection = LocalPlayer.Character.Humanoid.MoveDirection
        
        if humanoidRootPart and moveDirection.Magnitude > 0 then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveDirection * (Injection.Tech.speedvalue / 0.5)
        end
    end
end)

local function adjustAirTarget()
    if TargetPlr and TargetPlr.Character and TargetPlr.Character:FindFirstChild("Humanoid") then
        local state = TargetPlr.Character.Humanoid:GetState()
        
        if state == Enum.HumanoidStateType.Freefall then
            Injection.Tech.jumpoffset = Injection.Tech.jumpoffset3
            Injection.Tech.SelectedPart = Injection.Tech.AirPart
        elseif state == Enum.HumanoidStateType.Jumping then
            Injection.Tech.jumpoffset = Injection.Tech.jumpoffset2
        else
            Injection.Tech.SelectedPart = "HumanoidRootPart"
            Injection.Tech.jumpoffset = 0
        end
    end
end

RunService.Stepped:Connect(function()
    checkAutoAir()
    adjustAirTarget()
    updateAutoPrediction()
    
    if Injection.Tech.ViewAt and TargBindEnabled and TargetPlr and TargetPlr.Character then
        Camera.CameraSubject = TargetPlr.Character.Humanoid
    elseif not TargBindEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        Camera.CameraSubject = LocalPlayer.Character.Humanoid
    end
end)

local function AutoShoot()
    if TargBindEnabled and Injection.Tech.AutoShoot and LocalPlayer.Character then
        local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if tool then
            tool:Activate()
        end
    end
end

RunService.Heartbeat:Connect(function()
    if TargBindEnabled and Injection.Tech.Enabled then
        AutoShoot()
    end
end)

local UnlockTimer = 0
RunService.Heartbeat:Connect(function(DeltaTime)
    UnlockTimer = UnlockTimer + DeltaTime
    
    if UnlockTimer >= 0.1 and TargBindEnabled then
        if TargetPlr and TargetPlr.Character and TargetPlr.Character:FindFirstChild("Humanoid") then
            if Injection.Tech.UnlockOnKO and isPlayerKO(TargetPlr) then
                toggleCamlock()
                return
            end
        end
        UnlockTimer = 0
    end
end)

RunService.Heartbeat:Connect(function()
    if Injection.Tech.SilentMode and Injection.Tech.Enabled and not TargBindEnabled then
        TargetPlr = GetPlayerLookingAt()
        if not TargetPlr then
            TargetPlr = GetClosestToMouse()
        end
        
        if TargetPlr and TargetPlr.Character and TargetPlr.Character:FindFirstChild("Humanoid") then
            targetHealth = TargetPlr.Character.Humanoid.Health
        end
    end
end)

-- Keybind for hiding camlock button
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.H then
        CamlockButtonGUI.Enabled = not CamlockButtonGUI.Enabled
        Library:Notify({
            Title = "Camlock Button",
            Description = CamlockButtonGUI.Enabled and "Shown" or "Hidden",
            Time = 2,
        })
    end
end)

-- UI SETTINGS TAB
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "Custom Cursor",
    Default = true,
    Callback = function(Value)
        Library.ShowCustomCursor = Value
    end,
})

MenuGroup:AddDropdown("NotificationSide", {
    Values = {"Left", "Right"},
    Default = "Right",
    Text = "Notification Side",
    
    Callback = function(Value)
        Library:SetNotifySide(Value)
    end,
})

MenuGroup:AddDropdown("DPIDropdown", {
    Values = {"50%", "75%", "100%", "125%", "150%", "175%", "200%"},
    Default = "100%",
    Text = "DPI Scale",
    
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})

MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })
MenuGroup:AddButton("Unload", function() Library:Unload() end)

Library.ToggleKeybind = Options.MenuKeybind

-- ADDONS
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("InjectionAimbot")
SaveManager:SetFolder("InjectionAimbot")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()

-- STARTUP
print("========================================")
print("ðŸŽ¯ INJECTION AIMBOT LOADED")
print("========================================")
print("ðŸŽ¯ Camlock Button - Click to lock/unlock")
print("ðŸŽ¯ Red = Unlocked, Green = Locked")
print("ðŸ“± UI - RightShift to open")
print("ðŸŽ¯ Q Key - Camlock toggle (configurable)")
print("ðŸ”§ H Key - Hide/show camlock button")
print("ðŸš€ Movement - Walkspeed & Jump Power included")
print("ðŸŽ¯ Prediction - Now uses text box input (0.01 to 0.5)")
print("========================================")

-- Show welcome notification
Library:Notify({
    Title = "Injection Aimbot",
    Description = "Successfully loaded!",
    Time = 3,
})